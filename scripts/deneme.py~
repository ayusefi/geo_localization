#!/usr/bin/env python
from __future__ import print_function

import roslib
roslib.load_manifest('turtlebot_detection')
import sys
import rospy
import cv2
from std_msgs.msg import String
from sensor_msgs.msg import Image
from geometry_msgs.msg import TwistStamped
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import PointCloud2
import numpy as np
import math
import sensor_msgs.point_cloud2 as pc2

class image_converter:
  
  def __init__(self):
    self.coordinat_pub = rospy.Publisher("/object_geometry",TwistStamped,queue_size=3)
    self.bridge = CvBridge()
    self.image_sub = rospy.Subscriber("camera/rgb/image_raw",Image,self.callback,queue_size=3)
    self.depth_sub=rospy.Subscriber("/camera/depth/points", PointCloud2, self.callback_kinect,queue_size=3)
    self.data2=None
    self.dogrulama=0
    self.dogrulama1=0

  
  def callback_kinect(self,data):
  	self.data2=data


  def read_depth(self,width, height, data):
    data_out = pc2.read_points(data, field_names = ("x", "y", "z"), skip_nans=False, uvs=[[width,height]])
    return next(data_out) 



  def callback(self,data):
    try:
      cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")
    except CvBridgeError as e:
      print(e)

    lower=np.array([70,50,50],np.uint8)
    upper=np.array([150,255,255],np.uint8)
    
    blur=cv2.GaussianBlur(np.array(cv_image),(5,5),0)
    hsv=cv2.cvtColor(blur,cv2.COLOR_BGR2HSV)
    blue=cv2.inRange(hsv, lower, upper)

    blue=cv2.erode(blue,None,iterations=2)
    blue=cv2.dilate(blue,None,iterations=2)

   

    
    w=-1
    h=-1
    x=-1
    y=-1
    cntr,_=cv2.findContours(blue, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for i,c in enumerate(cntr):
        if cv2.contourArea(c)<1000:
            continue

        x1,y1,w1,h1=cv2.boundingRect(c)
        if w1*h1>w*h:
            w=w1
            h=h1
            x=x1
            y=y1
            
    if w!=-1:    
        cv2.rectangle(cv_image,(x,y),(x+w,y+h),(255,0,0),0)
        cv2.circle(cv_image,((x+w/2),(y+h/3)),3, (0,0,255), -1)
        cv2.circle(cv_image,((x+w/3),(y+2*h/3)),3, (0,0,255), -1)
        cv2.circle(cv_image,((x+2*w/3),(y+2*h/3)),3, (0,0,255), -1)
      
    print(str(self.dogrulama1))
    if self.data2!=None and w>15 and h>15:
	self.dogrulama1+=1
	if self.dogrulama1>100 and y>300:
	    	if not math.isnan(self.read_depth((x+w/2),(y+h/3),self.data2)[0]):
		        middle=self.read_depth((x+w/2),(y+h/2),self.data2)                
		        msg=TwistStamped()
			msg.header.frame_id="Mavi"
			msg.twist.linear.x=middle[0]
			msg.twist.linear.y=middle[1]
			msg.twist.linear.z=middle[2]              
			msg.twist.angular.x=0
			msg.twist.angular.y=0
			msg.twist.angular.z=0
			self.coordinat_pub.publish(msg)
			self.dogrulama1=0
    else:
	self.dogrulama1=0       	
		   


    cv2.waitKey(10)



    lower=np.array([20,100,100],np.uint8)
    upper=np.array([60,255,255],np.uint8)
    
    blur=cv2.GaussianBlur(np.array(cv_image),(5,5),0)
    hsv=cv2.cvtColor(blur,cv2.COLOR_BGR2HSV)
    green=cv2.inRange(hsv, lower, upper)

    green=cv2.erode(green,None,iterations=2)
    green=cv2.dilate(green,None,iterations=2)

   

    
    w=-1
    h=-1
    x=-1
    y=-1
    cntr,_=cv2.findContours(green, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for i,c in enumerate(cntr):
        if cv2.contourArea(c)<1000:
            continue

        x1,y1,w1,h1=cv2.boundingRect(c)
        if w1*h1>w*h:
            w=w1
            h=h1
            x=x1
            y=y1
            
    if w!=-1:    
        cv2.rectangle(cv_image,(x,y),(x+w,y+h),(255,255,0),0)
        cv2.circle(cv_image,((x+w/2),(y+h/3)),3, (0,0,255), -1)
        cv2.circle(cv_image,((x+w/3),(y+2*h/3)),3, (0,0,255), -1)
        cv2.circle(cv_image,((x+2*w/3),(y+2*h/3)),3, (0,0,255), -1)
      
    print(str(self.dogrulama))
    if self.data2!=None and w>15 and h>15:
	self.dogrulama+=1
	if self.dogrulama>100 and y>300:
	    	if not math.isnan(self.read_depth((x+w/2),(y+h/3),self.data2)[0]):
		        middle=self.read_depth((x+w/2),(y+h/2),self.data2)                
		        msg=TwistStamped()
			msg.header.frame_id="Yesil"
			msg.twist.linear.x=middle[0]
			msg.twist.linear.y=middle[1]
			msg.twist.linear.z=middle[2]              
			msg.twist.angular.x=0
			msg.twist.angular.y=0
			msg.twist.angular.z=0
			self.coordinat_pub.publish(msg)
			self.dogrulama=0
    else:
	self.dogrulama=0








    cv2.waitKey(10)	
    cv2.imshow("Imagewindow", cv_image)

    
    
   

def main(args):
  ic = image_converter()
  rospy.init_node('image_converter', anonymous=True) 
  try:
    rospy.spin()
  except KeyboardInterrupt:
    print("Shutting down")
  cv2.destroyAllWindows()

if __name__ == '__main__':
    main(sys.argv)
